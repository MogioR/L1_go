package main

import (
	"fmt"
	"math/rand"
	"os"
	"os/signal"
	"time"
)

/*
	Реализовать постоянную запись данных в канал (главный поток).
	Реализовать набор из N воркеров, которые читают произвольные
	данные из канала и выводят в stdout. Необходима возможность
	выбора количества воркеров при старте.

	Программа должна завершаться по нажатию Ctrl+C. Выбрать и
	обосновать способ завершения работы всех воркеров.
*/

/*
	Решение:

	Очевидное: как базовый вариант в windows ctrl + c вызывает
	закрытие консоли, как и в unix, в windows при таком подходе
	проблем нет.

	То которое требовалось?: можно с помощью os/signal перехватить
	сигнал на закрытие от ОС и обработать его.
*/

func main() {
	// Определяем количество исполнителей
	var countWorkers int
	fmt.Print("In workers: ")
	fmt.Fscan(os.Stdin, &countWorkers)

	// Канал под запись
	nums := make(chan int32)

	// Создаём исполнителей которые выполняются пока канал не закрыт
	for i := 0; i < countWorkers; i++ {
		go func(i int) {
			for item := range nums {
				fmt.Printf("Chanel %d: %d\n", i, item)
			}
		}(i)
	}

	// Создаем канал для прерывания, с помощью которого будем ожидать сигнала.
	exit := make(chan os.Signal, 1)
	signal.Notify(exit, os.Interrupt) // Привязываем канал к сигналу прерывания (Ctrl + C)

	// Горутина ожидающая прерывания
	go func() {
		<-exit
		// Закрытие канала с числами, для закрытия горутин
		close(nums)
		// Закрытие программы во избежание паника
		os.Exit(0)
	}()

	// Бесконечная запись в канал случайнык чисел
	for {
		nums <- rand.Int31()
		time.Sleep(500 * time.Millisecond)
	}
}
